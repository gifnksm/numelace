#!/usr/bin/env python3
from __future__ import annotations

import argparse
import math
import shlex
import sys
from pathlib import Path
from typing import Iterable, List, Optional, Tuple


def format_float(value: float) -> str:
    return f"{value:.3f}".rstrip("0").rstrip(".")


def parse_digits(raw: str) -> List[List[Optional[str]]]:
    cleaned = raw.strip().replace(" ", "")
    if "/" in cleaned:
        parts = cleaned.split("/")
        if len(parts) != 3:
            raise ValueError("digits must have 3 rows when using '/' separators")
        cleaned = "".join(parts)
    cleaned = cleaned.replace("\n", "")
    if len(cleaned) != 9:
        raise ValueError("digits must be 9 characters (use '.' or '0' for empty)")
    out: List[Optional[str]] = []
    for ch in cleaned:
        if ch in {".", "0", "_"}:
            out.append(None)
        elif ch.isdigit():
            out.append(ch)
        else:
            raise ValueError(f"invalid digit character: {ch}")
    return [out[i * 3 : (i + 1) * 3] for i in range(3)]


def parse_pen(raw: str) -> Tuple[int, int, float]:
    parts = raw.split(",")
    if len(parts) != 3:
        raise ValueError("pen must be formatted as row,col,angle_deg")
    row = int(parts[0])
    col = int(parts[1])
    angle = float(parts[2])
    if row not in (0, 1, 2) or col not in (0, 1, 2):
        raise ValueError("row and col must be 0..2")
    return row, col, angle


def compute_centers(
    start: float, size: float, outer_stroke: float
) -> Tuple[List[float], float, float]:
    inner_start = start + outer_stroke / 2.0
    inner_size = size - outer_stroke
    cell = inner_size / 3.0
    centers = [inner_start + cell / 2.0 + i * cell for i in range(3)]
    return centers, inner_start, cell


def pen_translate(
    target: Tuple[float, float], angle_deg: float, tip_x: float
) -> Tuple[float, float]:
    rad = math.radians(angle_deg)
    dx = tip_x * math.cos(rad)
    dy = tip_x * math.sin(rad)
    return target[0] - dx, target[1] - dy


def generate_svg(
    digits: List[List[Optional[str]]],
    pens: Iterable[Tuple[int, int, float]],
    output_path: Path,
    command_line: str,
) -> str:
    grid_color = "#38424A"
    pen_stroke = "#2F5BFF"
    pen_fill = "#9EB8FF"
    font_family = "Noto Sans, Segoe UI, Helvetica, Arial, sans-serif"

    grid_start = 102.0
    grid_size = 820.0
    grid_radius = 48.0
    outer_stroke = 60.0
    inner_stroke = 20.0
    inner_size = grid_size - outer_stroke
    inner_radius = max(0.0, grid_radius - outer_stroke / 2.0)
    font_size = 200

    pen_body_width = 220.0
    pen_body_height = 48.0
    pen_body_x = -170.0
    pen_body_y = -24.0
    pen_tip_x = 96.0
    pen_tip_base_x = 50.0
    pen_tip_half_height = 24.0

    centers, inner_start, cell = compute_centers(grid_start, grid_size, outer_stroke)
    first_div = inner_start + cell
    second_div = inner_start + cell * 2

    lines: List[str] = [
        '<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="1024" viewBox="0 0 1024 1024" fill="none">',
        "  <defs>",
        '    <clipPath id="icon-clip">',
        '      <rect x="0" y="0" width="1024" height="1024" rx="160"/>',
        "    </clipPath>",
        "  </defs>",
        "",
        "  <!-- Background -->",
        f"  <!-- Generated by: {command_line} -->",
        "",
        "  <!-- 3x3 Sudoku grid -->",
        f'  <rect x="{format_float(grid_start)}" y="{format_float(grid_start)}" width="{format_float(grid_size)}" height="{format_float(grid_size)}" rx="{format_float(grid_radius)}" fill="none" stroke="{grid_color}" stroke-width="{format_float(outer_stroke)}"/>',
        f'  <rect x="{format_float(inner_start)}" y="{format_float(inner_start)}" width="{format_float(inner_size)}" height="{format_float(inner_size)}" rx="{format_float(inner_radius)}" fill="#FFFFFF" stroke="none"/>',
        f'  <g stroke="{grid_color}" stroke-width="{format_float(inner_stroke)}" fill="none">',
        f'    <line x1="{format_float(first_div)}" y1="{format_float(grid_start)}" x2="{format_float(first_div)}" y2="{format_float(grid_start + grid_size)}"/>',
        f'    <line x1="{format_float(second_div)}" y1="{format_float(grid_start)}" x2="{format_float(second_div)}" y2="{format_float(grid_start + grid_size)}"/>',
        f'    <line x1="{format_float(grid_start)}" y1="{format_float(first_div)}" x2="{format_float(grid_start + grid_size)}" y2="{format_float(first_div)}"/>',
        f'    <line x1="{format_float(grid_start)}" y1="{format_float(second_div)}" x2="{format_float(grid_start + grid_size)}" y2="{format_float(second_div)}"/>',
        "  </g>",
        "",
        "  <!-- Digits -->",
        f'  <g fill="{grid_color}" font-family="{font_family}" font-weight="700" font-size="{font_size}" text-anchor="middle" dominant-baseline="central" alignment-baseline="central">',
    ]

    for row in range(3):
        for col in range(3):
            value = digits[row][col]
            if value is None:
                continue
            x = centers[col]
            y = centers[row]
            lines.append(
                f'    <text x="{format_float(x)}" y="{format_float(y)}">{value}</text>'
            )
        lines.append("")

    if lines[-1] == "":
        lines.pop()

    lines.extend(
        [
            "  </g>",
            "",
            "  <!-- Three pens (toward specified cell centers) -->",
            f'  <g stroke="{pen_stroke}" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="{pen_fill}" clip-path="url(#icon-clip)">',
        ]
    )

    for index, (row, col, angle) in enumerate(pens, start=1):
        target = (centers[col], centers[row])
        tx, ty = pen_translate(target, angle, pen_tip_x)
        lines.extend(
            [
                f"    <!-- Pen {index}: toward cell ({row}, {col}) center -->",
                f'    <g transform="translate({format_float(tx)} {format_float(ty)}) rotate({format_float(angle)})">',
                f'      <rect x="{format_float(pen_body_x)}" y="{format_float(pen_body_y)}" width="{format_float(pen_body_width)}" height="{format_float(pen_body_height)}" rx="0"/>',
                f'      <polygon points="{format_float(pen_tip_base_x)},{format_float(-pen_tip_half_height)} {format_float(pen_tip_x)},{format_float(0)} {format_float(pen_tip_base_x)},{format_float(pen_tip_half_height)}"/>',
                "    </g>",
                "",
            ]
        )

    if lines[-1] == "":
        lines.pop()

    lines.extend(
        [
            "  </g>",
            "",
            "",
            "</svg>",
            "",
        ]
    )

    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate the Numelace icon SVG.")
    parser.add_argument(
        "--output",
        default="assets/source/icon.svg",
        help="Output SVG path (relative to repo root).",
    )
    parser.add_argument(
        "--digits",
        default="836.7..25",
        help="9-char digit string (use '.' or '0' for empty). You can use '/' for rows.",
    )
    parser.add_argument(
        "--pen",
        action="append",
        default=[],
        help="Pen definition as row,col,angle_deg. Can be repeated.",
    )

    args = parser.parse_args()
    digits = parse_digits(args.digits)

    if args.pen:
        pens = [parse_pen(item) for item in args.pen]
    else:
        pens = [
            (1, 0, 135.0),
            (2, 0, 120.0),
            (1, 2, 45.0),
        ]

    output_path = Path(args.output)
    if not output_path.is_absolute():
        output_path = Path(__file__).resolve().parent.parent / output_path

    command_line = " ".join(shlex.quote(arg) for arg in sys.argv)
    svg_text = generate_svg(digits, pens, output_path, command_line)
    output_path.write_text(svg_text, encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
